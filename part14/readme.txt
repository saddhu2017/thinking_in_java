                                         第十四章 类型信息
运行时类型信息使得你可以在程序运行时发现和使用类型信息
java通过两种方式让我们在运行时识别对象和类的信息：一种是“传统的”RTTI，另一种是“反射”机制
14.1 为什么需要RTTI
向上转型会使编译器丢失一部分信息，而有时候你除了多态还确实需要另外一部分信息时，就需要知道运行时类型
14.2 Class对象
理解RTTI在java中的工作原理，首先要知道类型信息怎么表示：通过Class类对象表示。Class对象通过虚拟机的“类加载器”加载
类加载器子系统实际上可以包含一条类加载器链，所有的类都是第一次使用时被加载到JVM中的。
使用Class对象的三种方式1.Class.forName(String);2.ClassName.class;3.ClassObject.getClass()
为了实用类而做的准备工作实际上包含三个步骤：
1.加载；2.链接；3.初始化
Class类是一种泛型类，通过泛型类可以通过class.newInstance()方法创建确切的类型，<? super ClassName>除外
14.3 类型转换前先做检查
instanceof检查某个对象是否是某种类型的
14.4 注册工厂
把每个将要创建的类，用工厂的形式包装，增强代码的可扩展性
14.5 instanceof和Clas的等价性
instanceof保持了类型的概念，它指的是“你是这个类吗？或者你是这个类的派生类吗？”而==则比较实际的Class对象，没有考虑继承
14.6 反射：运行时的类信息
Class类与java.lang.reflect类库一起对反射进行支持，该类库包含Field/Method以及Constructor类（每个类都实现了Member接口）
要认识到反射机制没有什么神奇之处，它也是通过类加载器加载，通过Class来获取类中所包含的信息

14.7动态代理
动态代理可以动态地创建代理并动态地处理对所代理方法的调用。动态代理上所做的所有调用都会被重定向到单一的调用处理器上
