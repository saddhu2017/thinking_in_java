                                         第十四章 类型信息
运行时类型信息使得你可以在程序运行时发现和使用类型信息
java通过两种方式让我们在运行时识别对象和类的信息：一种是“传统的”RTTI，另一种是“反射”机制
14.1 为什么需要RTTI
多态是为了让代码只操纵基类，这样要添加一个新类，就不会影响到原来的代码。同时java中所有类型的检查和转化都是在运行时进行正确性检查
向上转型会使编译器丢失一部分信息，而有时候你除了多态还确实需要另外一部分信息时，就需要知道运行时类型
14.2 Class对象
理解RTTI在java中的工作原理，首先要知道类型信息怎么表示：通过Class类对象表示。Class对象通过虚拟机的“类加载器”加载
类加载器子系统实际上可以包含一条类加载器链，所有的类都是第一次使用时被加载到JVM中的。
Class对象谨在需要的时候才会加载，static初始化就是类加载过程中执行的
使用Class对象的三种方式1.Class.forName(String);2.ClassName.class;3.ClassObject.getClass()
为了实用类而做的准备工作实际上包含三个步骤：
1.加载；2.链接；3.初始化
Class类是一种泛型类，通过泛型类可以通过class.newInstance()方法创建确切的类型，<? super ClassName>除外
14.3 类型转换前先做检查
instanceof检查某个对象是否是某种类型的
14.4 注册工厂
把每个将要创建的类，用工厂的形式包装，增强代码的可扩展性
14.5 instanceof和Clas的等价性
instanceof保持了类型的概念，它指的是“你是这个类吗？或者你是这个类的派生类吗？”而==则比较实际的Class对象，没有考虑继承
14.6 反射：运行时的类信息
如果不知道一个对象的确切类型，RTTI可以告诉你，但有一个限制：这个类型在编译器必须已知
Class类与java.lang.reflect类库一起对反射进行支持，该类库包含Field/Method以及Constructor类（每个类都实现了Member接口）
要认识到反射机制没有什么神奇之处，它也是通过类加载器加载，通过Class来获取类中所包含的信息
通过反射可以提取类中所有的方法，包括继承字父类的，这就叫类方法提取
14.7动态代理
动态代理可以动态地创建代理并动态地处理对所代理方法的调用。动态代理上所做的所有调用都会被重定向到单一的调用处理器上，依次执行被代理对象中的方法
14.8 空对象
空对象正常具有唯一性，起站位作用
14.9 接口与类型信息
接口的重要目标就是允许程序员隔离构件，进而降低耦合性。但是通过类型信息，这种耦合性还是会传播出去。
通过反射，可以访问类中的私有属性和方法
14.10 总结
所有类在运行时都是最真实和透明的，通过反射能获得想要的类的几乎所有信息
