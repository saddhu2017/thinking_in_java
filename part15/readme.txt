                                         第十五章 泛型
  一般的类和方法，只能使用具体的类型：要么是基本类型，要么是自定义的类。如果要编写可以应用于多种类型的代码，这种刻板的限制对代码的束缚就会很大
  15.1 与C++的比较
  java主要来源于C++，特别是泛型设计
  15.2 简单泛型
  在类中组合单个对象，可以确切知道对象类型，如果使用基类（Object），可以使用所有类型，但是只限于多态层面，具体使用会造成类型转换的大量开销（运行时，泛型都会擦去成为Object，所以说泛型是一种编译器行为），泛型就是一种（具体的模糊类型）。当创建泛型类的对象时，必须指明想要持有什么类型，将其至于尖括号内
  15.3 泛型接口
  泛型也可以应用于接口，例如Generator，泛型接口跟泛型类统一模型，使用上没有多大差别，只是泛型接口提供规范
  15.4 泛型方法
  泛型方法使得该方法能够独立于类而产生变化。如果泛型方法可以取代整个类泛型化，那么应该只使用泛型方法。
  当使用泛型类时，必须在创建对象的时候指定类型参数的值，而使用泛型方法的时候，通常不必指明参数类型，因为编译器会为我们找出具体的类型，这陈伟参数类型推断。（泛型本质上是一个Object或一个边界值，所以相当于重载），静态方法使用泛型必须声明为静态泛型方法
  15.5 匿名内部类
  泛型还可以应用于匿名内部类
  15.6 构造复杂模型
  通过泛型可以很容易地创建List元组
  15.7 擦除的神秘之处
  java运行时只有ArrayList.class，没有ArrayList<Integer>.class
  在泛型代码内部，无法获得任何有关泛型参数类型的信息
  泛型擦除实际上在经过编译器处理后会擦除到它的第一个边界，边界通过<T extends HasF>定义
  为什么需要擦除：为了与不使用泛型的类保持一致兼容性（从非范化代码到泛化代码的转变过程，以及在不破坏现有类库的情况下，将泛型融入到java语言）
  擦除的代价是显著的，泛型不能用于显式的引用运行时类型的操作中，例如转型、instanceof、new表达式，当你希望类型参数不要仅仅当作Object处理时，就需要付出额外努力来管理边界（对象进入和离开方法的地点）
  15.19 总结：转型真的如此之遭吗？
  1.泛型区分类、接口或方法设计时泛型和使用时泛型
