                                               第十章 内部类
   可以将一个类的定义放在另一个类定义的内部，这就是内部类，内部类与组合是完全不同的概念
   10.1 创建内部类
   创建内部类的方式-把类的定义置于外围类的里面；同时可以通过外围类的方法，直接创建内部类对象;如果想从外部类的非静态方法之外的任意位置创建某个内部类的对象，必须指明这个对象的类型OuterClass.InnerClass
   10.2 链接到外部类
   内部类自动拥有对其外围类所有成员的访问权。（通过编译器在内部类对象里生成对外部类对象的引用，而外围类自动生成访问私有属性的方法供内部类使用）
   10.3 使用.this和.new
package part10;
public class OuterClass {
     class InnerClass{
        public OuterClass outer(){
            return OuterClass.this;
        }
    }
    public InnerClass inner(){
        return new InnerClass();
    }
    void f(){
        System.out.println("OuterClass.f()");
    }
}
class Other{
    public static void main(String[] args){
        OuterClass out = new OuterClass();
        OuterClass.InnerClass in = out.inner();
        in.outer().f();
    }
}
创建内部类必须依赖外部类对象的引用，如果没有外部类对象，则内部类无法创建成功
    10.4 内部类与向上转型
    通过内部类实现接口或者继承类而使用的类工厂模式，并搭配private关键字可以完全隐藏实现的细节
    10.5 在方法和作用域内的内部类
    局部内部类：1.定义在方法中的类；2.定义在方法中的某个作用域内；这并不能说明方法退出，或者离开作用域范围，此内部类就不再可用了。它是与其他类一起编译通过的，只是说明它们被藏得更深
    10.6 匿名内部类
    在需要某个类或者接口的对象时，可以直接通过new interfaceName（） or className（）｛｝；来创建匿名内部类，同时自动创建此类或接口的对象实现（说起来可能有点拗口）同时，除了匿名内部类方法之外的其他部分，都默认是在匿名内部类中进行（相当于，因为只有匿名内部类实例初始化可以有必须存在于方法中的操作，比如循环、if语句），而且匿名内部类只有一个构造器
    匿名内部类中处理的方法参数必须是final类型的
    10.7 嵌套类
    嵌套类其实就是静态内部类，静态内部类跟外部类基本没有什么联系，除了静态内部类可以访问外部类中的静态成分之外
    10.8 为什么需要内部类
    使用内部类最吸引人的原因就是：每个内部类都能独立地继承自一个（接口的）实现，所以无论外围类是否已经继承了某个接口的实现，对于内部类来说都没有影响，内部类解决了类似“多重继承”的问题。同时内部类还有其他一些特性：1.内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外围类对象的信息相互独立2.在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类3.创建内部类对象的时刻并不总是依赖外围类对象的创建4.内部类并没有令人迷惑的“is-a”关系，它是一个独立的实体
    闭包和回调-----回调就是我需要某个类型的接口对象时，直接创建实现了此接口的内部类（不论通过方法创建还是new）
    内部类与控制框架-----（事件触发，执行操作，具体什么操作，由子类决定）
    10.9 内部类的继承
    内部类的继承基本不会用到，如果用到了，子类的构造器的参数必须把外部类引用进来
    10.10 内部类可以被覆盖吗
    内部类实际上是依据其外部类来命名并创建的，所以不存在覆盖问题，即使子类中“覆盖了”父类的内部类，它们也是两个不同的内部类
    10.11 局部内部类
    局部内部类和匿名内部类基本相同，只局部内部类可以有构造器，且需要不止一个该内部类的对象
    10.12 内部类标识符
    每个内部类都会产生一个.class文件，命名方式OutClass$InnerClass.class
    10.13 总结
    内部类和接口是java面向对象中最深奥且最重要的部分，大部分设计模式都对它们存在依赖关系
